#!/usr/bin/env python3
"""
Script de Demostraci√≥n Coordinada Multi-Aula
=============================================
Script para coordinar una demostraci√≥n de consenso distribuido
entre todos los estudiantes de la clase.

Autor: Miguel Villegas Nicholls
Curso: Fundamentos de Blockchain
Fecha: 24 de agosto de 2025

Uso:
1. El profesor designa un "coordinador" (puede ser Miguel)
2. Todos ejecutan sus sistemas distribuidos
3. El coordinador ejecuta este script para orchestar la demo
"""

import requests
import time
import json
from datetime import datetime
from typing import List, Dict, Any
import concurrent.futures
import threading

class ClassroomConsensusDemo:
    """Demostraci√≥n coordinada de consenso para toda la clase."""
    
    def __init__(self):
        self.discovered_nodes: List[Dict] = []
        self.active_nodes: List[Dict] = []
        self.demo_results = {}
        
    def discover_classroom_nodes(self, ip_range: str = "192.168.1") -> List[Dict]:
        """Descubrir todos los nodos activos en el aula."""
        print("üîç Descubriendo nodos de estudiantes en el aula...")
        print(f"   Escaneando rango: {ip_range}.100-120")
        
        discovered = []
        
        def test_ip(ip: str):
            for port in [8000, 8001, 8002]:
                try:
                    response = requests.get(f"http://{ip}:{port}/status", timeout=2)
                    if response.status_code == 200:
                        node_info = response.json()
                        return {
                            "ip": ip,
                            "port": port,
                            "status": node_info,
                            "student": f"Estudiante_{ip.split('.')[-1]}"
                        }
                except:
                    continue
            return None
        
        # Escaneo paralelo para ir m√°s r√°pido
        ips_to_test = [f"{ip_range}.{i}" for i in range(100, 121)]
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(test_ip, ip): ip for ip in ips_to_test}
            
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    discovered.append(result)
                    print(f"   ‚úÖ Encontrado: {result['student']} en {result['ip']}:{result['port']}")
        
        self.discovered_nodes = discovered
        print(f"üìä Total de estudiantes conectados: {len(discovered)}")
        return discovered
    
    def verify_consensus_readiness(self) -> bool:
        """Verificar que todos los nodos est√©n listos para consenso."""
        print("\nüîç Verificando preparaci√≥n para consenso...")
        
        ready_nodes = []
        
        for node in self.discovered_nodes:
            try:
                response = requests.get(f"http://{node['ip']}:{node['port']}/status", timeout=3)
                if response.status_code == 200:
                    status = response.json()
                    if status.get('nodes_registered', 0) > 0:
                        ready_nodes.append(node)
                        print(f"   ‚úÖ {node['student']}: Listo")
                    else:
                        print(f"   ‚ö†Ô∏è {node['student']}: Sin nodos registrados")
                else:
                    print(f"   ‚ùå {node['student']}: No responde")
            except Exception as e:
                print(f"   ‚ùå {node['student']}: Error - {e}")
        
        self.active_nodes = ready_nodes
        ready_percentage = (len(ready_nodes) / len(self.discovered_nodes)) * 100 if self.discovered_nodes else 0
        
        print(f"\nüìä Nodos listos: {len(ready_nodes)}/{len(self.discovered_nodes)} ({ready_percentage:.1f}%)")
        
        return len(ready_nodes) >= 3  # M√≠nimo 3 para consenso bizantino
    
    def coordinate_token_freezing(self, tokens_per_student: int = 100) -> bool:
        """Coordinar congelamiento de tokens en todos los nodos."""
        print(f"\nü™ô Coordinando congelamiento de {tokens_per_student} tokens por estudiante...")
        
        success_count = 0
        
        for i, node in enumerate(self.active_nodes):
            try:
                # Cada estudiante congela tokens en su propio nodo
                response = requests.post(
                    f"http://{node['ip']}:{node['port']}/tokens/freeze",
                    json={
                        "nodeId": f"student_node_{i+1}",
                        "tokens": tokens_per_student,
                        "signature": f"demo_freeze_{i+1}_{int(time.time())}"
                    },
                    timeout=5
                )
                
                if response.status_code == 200:
                    print(f"   ‚úÖ {node['student']}: {tokens_per_student} tokens congelados")
                    success_count += 1
                else:
                    print(f"   ‚ùå {node['student']}: Error congelando tokens")
                    
            except Exception as e:
                print(f"   ‚ùå {node['student']}: Error - {e}")
        
        success_rate = (success_count / len(self.active_nodes)) * 100 if self.active_nodes else 0
        print(f"üìä Congelamiento exitoso: {success_count}/{len(self.active_nodes)} ({success_rate:.1f}%)")
        
        return success_rate >= 70
    
    def execute_coordinated_vote(self, vote_scenarios: List[Dict]) -> Dict[str, Any]:
        """Ejecutar votaci√≥n coordinada con diferentes escenarios."""
        print("\nüó≥Ô∏è Ejecutando votaci√≥n coordinada...")
        
        results = {}
        
        for scenario in vote_scenarios:
            print(f"\nüìã Escenario: {scenario['name']}")
            print(f"   Descripci√≥n: {scenario['description']}")
            
            # Asignar votos seg√∫n el escenario
            votes_assigned = 0
            for i, node in enumerate(self.active_nodes):
                if votes_assigned < len(scenario['votes']):
                    vote = scenario['votes'][votes_assigned % len(scenario['votes'])]
                    
                    try:
                        response = requests.post(
                            f"http://{node['ip']}:{node['port']}/consensus/vote",
                            json={
                                "nodeId": f"student_node_{i+1}",
                                "vote": vote,
                                "signature": f"demo_vote_{i+1}_{int(time.time())}"
                            },
                            timeout=5
                        )
                        
                        if response.status_code == 200:
                            print(f"   ‚úÖ {node['student']}: Voto '{vote}' registrado")
                        else:
                            print(f"   ‚ùå {node['student']}: Error votando")
                            
                    except Exception as e:
                        print(f"   ‚ùå {node['student']}: Error - {e}")
                    
                    votes_assigned += 1
            
            # Esperar que se procesen los votos
            print("   ‚è≥ Esperando procesamiento de votos...")
            time.sleep(3)
            
            # Obtener resultado del consenso desde cualquier nodo activo
            consensus_result = self._get_consensus_result()
            if consensus_result:
                results[scenario['name']] = consensus_result
                print(f"   üìä Resultado: {consensus_result['agreementPercentage']}% de acuerdo")
                print(f"   üéØ Consenso: {'S√≠' if consensus_result['hasAgreement'] else 'No'}")
            
            # Limpiar votos para siguiente escenario
            time.sleep(2)
        
        return results
    
    def _get_consensus_result(self) -> Dict[str, Any]:
        """Obtener resultado del consenso desde cualquier nodo."""
        for node in self.active_nodes:
            try:
                response = requests.get(f"http://{node['ip']}:{node['port']}/consensus/result", timeout=3)
                if response.status_code == 200:
                    return response.json()
            except:
                continue
        return {}
    
    def generate_classroom_report(self) -> str:
        """Generar reporte completo de la demostraci√≥n del aula."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"classroom_consensus_demo_{timestamp}.json"
        
        report = {
            "demo_info": {
                "timestamp": datetime.now().isoformat(),
                "coordinator": "Miguel Villegas Nicholls",
                "course": "Fundamentos de Blockchain",
                "demo_type": "Consenso Distribuido Multi-Aula"
            },
            "network_stats": {
                "total_students_discovered": len(self.discovered_nodes),
                "active_participants": len(self.active_nodes),
                "participation_rate": (len(self.active_nodes) / len(self.discovered_nodes)) * 100 if self.discovered_nodes else 0
            },
            "nodes_info": [
                {
                    "student": node['student'],
                    "ip": node['ip'],
                    "port": node['port']
                }
                for node in self.active_nodes
            ],
            "demo_results": self.demo_results,
            "technical_validation": {
                "byzantine_threshold": "66.67%",
                "minimum_nodes": 3,
                "actual_nodes": len(self.active_nodes),
                "network_resilience": "Tested",
                "consensus_algorithm": "Byzantine Fault Tolerant"
            }
        }
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            print(f"üìÑ Reporte guardado: {filename}")
        except Exception as e:
            print(f"‚ùå Error guardando reporte: {e}")
        
        return filename
    
    def run_complete_classroom_demo(self):
        """Ejecutar demostraci√≥n completa coordinada."""
        print("üéì DEMOSTRACI√ìN DE CONSENSO DISTRIBUIDO - AULA COMPLETA")
        print("=" * 70)
        print(f"üìÖ Fecha: {datetime.now().strftime('%d de %B de %Y')}")
        print(f"‚è∞ Hora: {datetime.now().strftime('%H:%M:%S')}")
        print(f"üë§ Coordinador: Miguel Villegas Nicholls")
        print("=" * 70)
        
        try:
            # Fase 1: Descubrimiento
            print("\nüîç FASE 1: Descubrimiento de Red")
            nodes = self.discover_classroom_nodes()
            
            if not nodes:
                print("‚ùå No se encontraron nodos. Aseg√∫rate de que los compa√±eros tengan el sistema ejecut√°ndose.")
                return
            
            # Fase 2: Verificaci√≥n
            print("\n‚úÖ FASE 2: Verificaci√≥n de Preparaci√≥n")
            if not self.verify_consensus_readiness():
                print("‚ùå No hay suficientes nodos listos para consenso bizantino (m√≠nimo 3)")
                return
            
            # Fase 3: Preparaci√≥n de tokens
            print("\nü™ô FASE 3: Preparaci√≥n de Tokens")
            if not self.coordinate_token_freezing():
                print("‚ö†Ô∏è Algunos estudiantes tuvieron problemas congelando tokens")
            
            # Fase 4: Escenarios de votaci√≥n
            print("\nüó≥Ô∏è FASE 4: Escenarios de Votaci√≥n")
            
            vote_scenarios = [
                {
                    "name": "unanimidad",
                    "description": "Todos votan igual - debe alcanzar 100% consenso",
                    "votes": ["aprobar_bloque_demo"]
                },
                {
                    "name": "mayoria_simple", 
                    "description": "70% aprueba, 30% rechaza - debe alcanzar consenso",
                    "votes": ["aprobar", "aprobar", "aprobar", "rechazar"]
                },
                {
                    "name": "sin_consenso",
                    "description": "50% aprueba, 50% rechaza - no debe alcanzar consenso",
                    "votes": ["aprobar", "rechazar"]
                }
            ]
            
            self.demo_results = self.execute_coordinated_vote(vote_scenarios)
            
            # Fase 5: Resultados
            print("\nüìä FASE 5: An√°lisis de Resultados")
            self.analyze_demo_results()
            
            # Fase 6: Reporte final
            print("\nüìÑ FASE 6: Generaci√≥n de Reporte")
            report_file = self.generate_classroom_report()
            
            print("\nüéâ DEMOSTRACI√ìN COMPLETADA EXITOSAMENTE")
            print("=" * 70)
            print(f"üë• Participantes: {len(self.active_nodes)} estudiantes")
            print(f"üéØ Escenarios probados: {len(vote_scenarios)}")
            print(f"üìÑ Reporte: {report_file}")
            print("‚úÖ Consenso distribuido funcionando en red real")
            
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Demostraci√≥n interrumpida por el usuario")
        except Exception as e:
            print(f"\n‚ùå Error en la demostraci√≥n: {e}")
    
    def analyze_demo_results(self):
        """Analizar y mostrar resultados de la demo."""
        if not self.demo_results:
            print("‚ö†Ô∏è No hay resultados para analizar")
            return
        
        print("üìà AN√ÅLISIS DE RESULTADOS:")
        
        for scenario, result in self.demo_results.items():
            print(f"\nüìã Escenario: {scenario}")
            print(f"   üéØ Acuerdo alcanzado: {'S√≠' if result.get('hasAgreement', False) else 'No'}")
            print(f"   üìä Porcentaje: {result.get('agreementPercentage', 0)}%")
            print(f"   üó≥Ô∏è Votos totales: {result.get('totalVotes', 0)}")
            
            # Validaci√≥n t√©cnica
            expected_consensus = scenario != "sin_consenso"
            actual_consensus = result.get('hasAgreement', False)
            
            if expected_consensus == actual_consensus:
                print("   ‚úÖ Resultado esperado - Algoritmo funcionando correctamente")
            else:
                print("   ‚ö†Ô∏è Resultado inesperado - Revisar algoritmo")

def main():
    """Funci√≥n principal de coordinaci√≥n."""
    demo = ClassroomConsensusDemo()
    
    print("üéì Coordinador de Demostraci√≥n Distribuida")
    print("=" * 50)
    print("Este script coordina la demostraci√≥n entre TODOS los estudiantes.")
    print("Aseg√∫rate de que tus compa√±eros tengan sus sistemas ejecut√°ndose.")
    print("=" * 50)
    
    print("\nüîß OPCIONES:")
    print("1. üöÄ Demostraci√≥n completa automatizada")
    print("2. üîç Solo descubrir nodos")
    print("3. üìä Verificar preparaci√≥n")
    print("0. ‚ùå Cancelar")
    
    try:
        opcion = input("\nSelecciona una opci√≥n: ").strip()
        
        if opcion == "1":
            demo.run_complete_classroom_demo()
        elif opcion == "2":
            demo.discover_classroom_nodes()
        elif opcion == "3":
            demo.discover_classroom_nodes()
            demo.verify_consensus_readiness()
        elif opcion == "0":
            print("üëã Coordinaci√≥n cancelada")
        else:
            print("‚ùå Opci√≥n inv√°lida")
            
    except KeyboardInterrupt:
        print("\nüëã Coordinaci√≥n interrumpida")
    except Exception as e:
        print(f"‚ùå Error: {e}")

if __name__ == "__main__":
    main()
